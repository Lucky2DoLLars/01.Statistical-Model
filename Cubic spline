n <- 20
X <- (1:n)/(n+1)
set.seed(101)
h <- diff(X)
vecg <- sin(2*pi*X) + rnorm(n,sd=0.25)
plot(X, vecg, pch=4, xlim=c(0,1), xlab="x", ylab="y", main = "Cubic Spline")
#

n <- length(X)
R <- matrix(0,n-2,n-2)

for(i in 1:(n-2)) R[i,i] <- (h[i]+h[i+1])/3
for(i in 1:(n-3))
	{
	R[i,i+1] <- h[i+1]/6
	R[i+1,i] <- h[i+1]/6
	}

Q <- matrix(0,n,n-2)

for(i in 1:(n-2))
	{
	Q[i,i] <- 1/h[i]
	Q[i+1,i] <- -1/h[i] - 1/h[i+1]
	Q[i+2,i] <- 1/h[i+1]
	}

g <- function(x,vecg)
	{
	gamma <- solve(R) %*% t(Q) %*% vecg
	gamma <- c(0,gamma,0)

	gprime1 <- (vecg[2] - vecg[1])/h[1] - (1/6)*h[1]*gamma[2]
	gprimen <- (vecg[n] - vecg[n-1])/h[n-1] + (1/6)*h[n-1]*gamma[n-1]
	Sum <- 0

	for(i in 1:(n-1))
		{
		Summand <- (((x-X[i])*vecg[i+1] + (X[i+1] - x)*vecg[i])/h[i] - (1/6)*(x-X[i])*(X[i+1]-x)*((1+(x-X[i])/h[i])*gamma[i+1] + (1 + (X[i+1]-x)/h[i])*gamma[i]))*(x >= X[i])*(x < X[i+1])

		Sum <- Sum + Summand
		}

	Sum <- Sum + (vecg[1] - (X[1]-x)*gprime1)*(x >=0)*(x < X[1]) + (vecg[n] + (x-X[n])*gprimen)*(x >= X[n])*(x <= 1)

	return(Sum)
	}



# lambda grid search

number_lambdas = 100000
lambda = seq(from = 10e-5, to = 10e-1, length.out = number_lambdas)
cv_score = rep(NA, number_lambdas)

for(i in 1 : number_lambdas)
{
   K <- Q %*% solve(R) %*% t(Q)
   Y <- vecg
   vecg2 <- solve(diag(rep(1, n)) + lambda[i] * K) %*% Y
   A <- solve(diag(rep(1, n)) + lambda[i] * K)
   diag_A <- diag(A)
   cv_score[i] <- mean( ((Y - vecg2)/(1 - diag_A))^2 )
}


x0 <- seq(0,1,length=1001)
plot(X, vecg, pch=4, xlim=c(0,1), xlab="x", ylab="y", main = "Cubic Smoothing Spline")
lines(x0,sin(2*pi*x0), lwd = 1, col = "blue") #true regression curve
